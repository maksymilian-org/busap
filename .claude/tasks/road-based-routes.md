Work inside the existing Busap monorepo.
Assume current route geometry is implemented as straight-line segments between stops.

GOAL:
Integrate openrouteservice to generate road-based routes and allow user-adjustable routing.

---

## 1. openrouteservice INTEGRATION
Use openrouteservice public API (free tier for now).

API key:


Requirements:
- Centralize ORS client in backend
- Configurable via env
- Easy to swap later to self-hosted ORS (Docker)

---

## 2. ROUTE GEOMETRY LOGIC
Change route composition logic:

Current:
- Route = straight lines between stops

Target:
- Route = road-based geometry generated by ORS
- Input:
  - Ordered list of stops (lat/lng)
  - Optional intermediate waypoints

Behavior:
- On route creation:
  - Generate default road-based path between stops
- On route edit:
  - Allow adding/removing intermediate waypoints
  - Recompute geometry via ORS
- Store:
  - Final geometry (polyline / GeoJSON)
  - Waypoints used to generate it

---

## 3. USER-EDITABLE ROUTE (MAP UX)
Frontend requirements (web first):
- Display generated route on map
- Allow user to modify route by:
  - Dragging path OR
  - Adding intermediate waypoints (Google Mapsâ€“like behavior)
- Each modification triggers route recomputation via backend

Do NOT implement advanced map editing UI if not already present.
Reuse existing map stack.

---

## 4. DATA MODEL
Extend existing Route model:
- geometry (GeoJSON or encoded polyline)
- waypoints (ordered list of coordinates)
- distance (meters)
- estimatedDuration (seconds)

---

## 5. BACKEND API
Add endpoints or extend existing ones:
- Generate route geometry from stops + waypoints
- Update route geometry on edit

Keep API minimal.

---

## 6. VALIDATION / NOTES
- If ORS is not appropriate for this use case, clearly state why and propose the minimal viable alternative.
- Do NOT implement traffic-aware ETA yet.
- Design must allow future:
  - Live Traffic provider
  - Historical ETA analysis

---

## OUTPUT RULES
Return ONLY:
1. Decision: confirm ORS suitability (or short correction)
2. Data model changes
3. Backend integration points
4. Frontend changes (file-level)
5. Example request/response for route generation

No explanations beyond what is necessary.
